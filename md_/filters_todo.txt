Как реализовать фильтры
(заодно про небольшие оптимизации)

Надо сделать детектор, является ли значение variant'а фильтром, или нет.
Зачем - пока не знаю, но кажется, что пригодится.

Далее.

Надо переделать processFormatStringImpl так, чтобы она принимала
функтор, который преобразует строковый идентификатор аргумента
в индекс.

В итоге processFormatStringImpl хоть сама и не знает, как обрабатываются
ссылки, но делает немного больше, чем тупо сохраняет строки со ссылками на аргумента.

Функтор получения индекса сам обрабатывает ошибки не найденного индекса,
кидает исключение, если индекс не найден, в соответсвии со стратегией обработки
ошибок.

Функтор получения индекса получает, кроме строки индекса также
тип индекса:
FormatIndexType
 argId
 fillRef
 widthRef
 precisionRef
 filterRef

Функтор получения индекса, если не кидает исключения,
при ошибке возвращает std::size_t(-1).

Если функтор получения индекса возвращает -1, то устанавливаем, что соотв поле не установлено вообще.

В FormattingOptions убираем все строки, всё строковые имена заменяем на индексы.

Оптимизация.
Тип индекса аргумента делаем std::uint16_t - вряд ли столько аргументов может быть в реальной жизни,
но не делаем std::uint8_t - таки 256 аргументов хоть и выглядит большим числом, но теоретически 
такое может быть.

Когда функтор получения индекса аргумента получает строку для преобразования в индекс аргумента,
и типом ссылки является FormatIndexType::filterRef, что нам следует сделать?

- надо проверить, что такой элемент есть в переданных аргументах
- надо проверить, что этот элемент является фильтром
  (ага, я таки подозревал, что функция проверки, является ли variant значение фильтром - пригодится 
  где-то, чуйка, ёпта)

  Если всё хорошо - возвращаем индекс аргумента

Но. Мы, например, хотим из какой-то своей скриптоты/DSL вызвать функцию форматирования.
При этом хотим использовать фильтры (нам надо, например, выводить в HTML/XML/SVG, и 
экранировать базовые entity, или мы генерируем SQL запрос).

Но при этом наш язык не позволяет нам самим как-то создавать фильтры, и мы надеемся
на то, что нам предоставляет библиотека и/или её расширения.

И что же нам делать?

Добавляем для нашей функции форматирования шаблонный параметр - FilterFactory,
задаём по дефолту стандартную фабрику, которая умеет создавать xml/html/sql фильтры,
и умеет возвращать объекты фильтров по имени, например, "xml"/"xml-text"/"xml-attr",
"html"/"html-text"/"html-attr", или "sql".

Так вот, что же мы делаем, если мы не смогли найти фильтр по имени в аргументах,
или аргумент не является фильтром?

Мы заводим в функции форматирования массив чисто фильтров, и вставляем туда фильтры, 
которые не были заданы в аргументах для форматирования.

Если фильтр не найден в переданных аргументах (условия см. выше), то дергаем фабрику,
она возвращает объект фильтра, возвращаем индекс фильтра в нашем локальном массиве,
устанавливая, например, старший бит индекса в единицу, как маркер того, что искать надо 
не в аргументах, а в локальном массиве фильтров.

Если фабрика вернула -1, то это хз, что за фильтр. Тут надо подумать, либо сделать
дефолтный фильтр типа pass_through, либо вернуть -1 дальше, и просто исключить
его из цепочки фильтров. Или кинуть иключение, чт фильтр неизвестен.

Тут надо подумать, не слишком ли жирно каждый раз при ссылке на использование фильтра
создавать новый объект фильтра, и класть его в контейнер фильтров, или тут надо как-то
кешировать и по возможности возвращать индексы ранее добавленных фильтров.

И ещё. Сравнивать строковые имена фильтров со строками в стандартной фабрике фильтров
как-то так себе. Заведём enum-тип StdFilterType со значениями
  xml
  xmlText
  xmlAttr
  html
  htmlText
  htmlAttr
  sql

StdFilterType заведём при помощи umba-enum-gen, он нам нагенерит кучу имен
в разных стилях - kebab-style, snake_style, PascalStyle и тп, по которым сможет 
сконвертировать строку в значение enum.
Также будет сгенерирована функция enum_deserialize для данного enum.

Ну вот, план вроде готов, полный и непротиворечивый, теперь только хуярить код.
